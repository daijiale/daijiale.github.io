
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>下次人家问再你怎么入门AndroidWear，你就甩这篇文章给TA | DaiJiale&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Jiale Dai">
    

    
    <meta name="description" content="本文作者
Jiale Dai成都 电子科技大学 本科生( 其实还没毕业，目前大三 ）
从14年开始一直专研于AndroidWear开发

摘要： 本文是Jiale Dai 在学习Google官方视频、开发者文档和实践项目之后整理出来的心得笔记，是以一个个人开发者的角度给大家带来一些侧面对Android Wear开发的看法，不同于一些传统的Android Wear技术开发教程，但是博主希望能通过自己">
<meta property="og:type" content="article">
<meta property="og:title" content="下次人家问再你怎么入门AndroidWear，你就甩这篇文章给TA">
<meta property="og:url" content="http://daijiale.github.io/2015/05/04/最全的AndroidWear开发笔记/index.html">
<meta property="og:site_name" content="DaiJiale's Blog">
<meta property="og:description" content="本文作者
Jiale Dai成都 电子科技大学 本科生( 其实还没毕业，目前大三 ）
从14年开始一直专研于AndroidWear开发

摘要： 本文是Jiale Dai 在学习Google官方视频、开发者文档和实践项目之后整理出来的心得笔记，是以一个个人开发者的角度给大家带来一些侧面对Android Wear开发的看法，不同于一些传统的Android Wear技术开发教程，但是博主希望能通过自己">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/djlblogpicslrme.jpg">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidweargmail.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearsinglecard.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearmuticard.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearhangouts.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearcamera.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearmaps.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/djlblog_androidwear_cloud.JPG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearstreamapps.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearcarddesigner.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidweargooglenowcard.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidweargradpagerview.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearcontentPage.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/github_androidwear23.png">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmutinotifi.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmutinotifi2.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblognotifistack.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmusicstatus.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmusicstatus0.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblognotifiwearmoban.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmobile_wear_noti.PNG">
<meta property="og:image" content="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogAndroidWear-CN.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="下次人家问再你怎么入门AndroidWear，你就甩这篇文章给TA">
<meta name="twitter:description" content="本文作者
Jiale Dai成都 电子科技大学 本科生( 其实还没毕业，目前大三 ）
从14年开始一直专研于AndroidWear开发

摘要： 本文是Jiale Dai 在学习Google官方视频、开发者文档和实践项目之后整理出来的心得笔记，是以一个个人开发者的角度给大家带来一些侧面对Android Wear开发的看法，不同于一些传统的Android Wear技术开发教程，但是博主希望能通过自己">

    
    <link rel="alternative" href="/atom.xml" title="DaiJiale&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="DaiJiale&#39;s Blog" title="DaiJiale&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="DaiJiale&#39;s Blog">DaiJiale&#39;s Blog</a></h1>
				<h2 class="blog-motto">只有汗水不会欺骗你 || Only sweat will not fail you</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于我</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:daijiale.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/04/最全的AndroidWear开发笔记/" title="下次人家问再你怎么入门AndroidWear，你就甩这篇文章给TA" itemprop="url">下次人家问再你怎么入门AndroidWear，你就甩这篇文章给TA</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Jiale Dai" target="_blank" itemprop="author">Jiale Dai</a>
		
  <p class="article-time">
    <time datetime="2015-05-04T08:23:09.000Z" itemprop="datePublished"> 发表于 2015-05-04</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#本文作者"><span class="toc-number">1.</span> <span class="toc-text">本文作者</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Jiale_Dai"><span class="toc-number">1.1.</span> <span class="toc-text">Jiale Dai</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#写在开头"><span class="toc-number">2.</span> <span class="toc-text">写在开头</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#核心元素："><span class="toc-number">2.1.</span> <span class="toc-text">核心元素：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建一个Wear_Apps的基础（wear_app能做到什么？）："><span class="toc-number">2.2.</span> <span class="toc-text">构建一个Wear Apps的基础（wear app能做到什么？）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gmail"><span class="toc-number">2.2.1.</span> <span class="toc-text">Gmail</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hangouts"><span class="toc-number">2.2.2.</span> <span class="toc-text">Hangouts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Google_Camera"><span class="toc-number">2.2.3.</span> <span class="toc-text">Google Camera</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Google_Maps"><span class="toc-number">2.2.4.</span> <span class="toc-text">Google Maps</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#搭建云驱动的Android_Wear_Apps"><span class="toc-number">3.</span> <span class="toc-text">搭建云驱动的Android Wear Apps</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#写给设计师们：如何把握Android_Wear下App的设计原则？"><span class="toc-number">4.</span> <span class="toc-text">写给设计师们：如何把握Android Wear下App的设计原则？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#设计思路："><span class="toc-number">4.1.</span> <span class="toc-text">设计思路：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear搭建更高级别的UI"><span class="toc-number">5.</span> <span class="toc-text">Android Wear搭建更高级别的UI</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear_数据层API_DevBytes"><span class="toc-number">6.</span> <span class="toc-text">Android Wear 数据层API DevBytes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear的提醒（Notification）新特性"><span class="toc-number">7.</span> <span class="toc-text">Android Wear的提醒（Notification）新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多页面提醒设计（Multi-page_notifications）"><span class="toc-number">7.1.</span> <span class="toc-text">多页面提醒设计（Multi-page notifications）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提醒堆栈（Notification_Stacks）"><span class="toc-number">7.2.</span> <span class="toc-text">提醒堆栈（Notification Stacks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远程输入（Remote_Input）"><span class="toc-number">7.3.</span> <span class="toc-text">远程输入（Remote Input）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Custom_Display_Cards"><span class="toc-number">7.4.</span> <span class="toc-text">Custom Display Cards</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Notification_Bridging"><span class="toc-number">7.5.</span> <span class="toc-text">Notification Bridging</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear下的全屏App设计理念"><span class="toc-number">8.</span> <span class="toc-text">Android Wear下的全屏App设计理念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#让用户如何退出APP"><span class="toc-number">8.1.</span> <span class="toc-text">让用户如何退出APP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#滑动退出："><span class="toc-number">8.1.1.</span> <span class="toc-text">滑动退出：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear表盘（WatchFace）设计与开发"><span class="toc-number">9.</span> <span class="toc-text">Android Wear表盘（WatchFace）设计与开发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear更多系列教程："><span class="toc-number">10.</span> <span class="toc-text">Android Wear更多系列教程：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Google_Play_上热门的Android_Wear应用"><span class="toc-number">11.</span> <span class="toc-text">Google Play 上热门的Android Wear应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#热门的可穿戴技术社区"><span class="toc-number">12.</span> <span class="toc-text">热门的可穿戴技术社区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear相关产品宣传视频"><span class="toc-number">13.</span> <span class="toc-text">Android Wear相关产品宣传视频</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#加入我们"><span class="toc-number">14.</span> <span class="toc-text">加入我们</span></a></li></ol>
		
		</div>
		
		<h1 id="本文作者">本文作者</h1><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/djlblogpicslrme.jpg" alt=""></p>
<h2 id="Jiale_Dai"><a href="http://www.daijiale.cn" target="_blank" rel="external">Jiale Dai</a></h2><p>成都 电子科技大学 本科生( 其实还没毕业，目前大三 ）</p>
<p>从14年开始一直专研于AndroidWear开发</p>
<blockquote>
<p><strong>摘要：</strong> 本文是Jiale Dai 在学习Google官方视频、开发者文档和实践项目之后整理出来的心得笔记，是以一个个人开发者的角度给大家带来一些侧面对Android Wear开发的看法，不同于一些传统的Android Wear技术开发教程，但是博主希望能通过自己对这些知识的整理和资源的收集，给读者带了一份详尽的、多角度的Android Wear指南。<strong>无论你是程序员，设计师，产品经理，还是手表极客 ，Android Wear用户 or 小白，都能在这篇博文中找到你想要的Android Wear元素。</strong><br>博文会同时托管到Github上，欢迎更多承载着开源精神的有心人加入，分享你对Android Wear的见解。<br><a id="more"></a></p>
</blockquote>
<h1 id="写在开头">写在开头</h1><blockquote>
<p><strong>自己对AndroidWear的看法：</strong></p>
<p>Android Wear的目标就是：不接触手机的前提下，在你需要的时候，它把对你有用的信息呈现给你，扫一眼就够了。ta是<br>一种新的交互模型，有很多有利便捷新潮的交互体验是手机上无法实现的。将你自己置身于一个外部场景，在移动和忙碌中使用这项服务是什么样的体验，你就会发现ta的价值。</p>
</blockquote>
<p><strong>下面我们来欣赏一段Android Wear的应用场景视频</strong>（博主花了大精力才从鹅厂官网漏洞里抓取到的外链地址，<strong>低调、低调</strong>）：</p>
<h2 id="核心元素：">核心元素：</h2><ul>
<li>Google Now：用户可以和AndroidWear“说话”（语音交互）。</li>
<li>Notifications:一个卡片，一个提醒，实现你最想要的服务。具体分为stacks、 pages、 replies、三种性质。</li>
<li>WatchFace：表之所以称之为“表”。</li>
<li>Data Message：和手机的数据通信机制是重要的桥梁。</li>
</ul>
<h2 id="构建一个Wear_Apps的基础（wear_app能做到什么？）：">构建一个Wear Apps的基础（wear app能做到什么？）：</h2><p><strong>基础API元素:</strong></p>
<ul>
<li>Custom UI</li>
<li>Send Data</li>
<li>Control Sensors</li>
<li>Voice Actions</li>
</ul>
<p>下面我会举<strong>四个例子</strong>来说明基于这几个基础元素（Android Wear API）可以实现什么样级别的<strong>Wear App</strong>：</p>
<h3 id="Gmail">Gmail</h3><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidweargmail.PNG" alt=""></p>
<ul>
<li>Gmail Base On<ul>
<li>Notification Bundles</li>
<li>RemoteInput for Voice Response</li>
</ul>
</li>
</ul>
<p>大家应该不会陌生Gmail，下面来看看其在wear端的app特性：</p>
<p>1、首先ta有两种邮件提醒类型：</p>
<p><strong>单页通知卡片（如下图）</strong></p>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearsinglecard.PNG" alt=""></p>
<p><strong>多页通知卡片（如下图）</strong></p>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearmuticard.PNG" alt=""></p>
<p>2、你可以通过滑动卡片，进一步了解更多信息，而且伴随有 <strong>“语音快速回复” “归档” “在手机端打开回复”</strong>三种操作，这里我们重点谈一下<strong>语音快速回复</strong>这个<strong>具有wear特性</strong>的操作流程：</p>
<ul>
<li><code>Android Notification API</code> 会让你通过远程输入给reply行为做一个注释,而远程输入则会告诉AndroidWear，在执行这个行为之前，你要把文本输入的方式改为语音，因此当Gmail建立一个notification连接时，wear端会给reply行为附加一个远程输入，AndroidWear会看到这条远程输入，然后不会立即发送一个行为，会首先启动一个wear UI界面来收集语音回复信息，然后把转换好的文本变成意图，再发送意图到你的手机上，手机得到意图后，就可以在不触动手机UI的情况下发送/回复邮件了。</li>
</ul>
<p>下面是关键代码实现过程：</p>
<p><strong>Add RemoteInput to Reply Action</strong></p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Action</span> replyAction = <span class="keyword">new</span> <span class="type">NotificationCompat</span>.<span class="type">Action</span>.<span class="type">Builder</span>(</span><br><span class="line">	<span class="type">R</span>.drawble.ic_reply,getString(<span class="type">R</span>.<span class="built_in">string</span>.reply), </span><br><span class="line">	replyPendingIntent)</span><br><span class="line">    addRemoteInput(</span><br><span class="line">	  <span class="keyword">new</span> <span class="type">RemoteInput</span>.<span class="type">Builder</span>(<span class="type">EXTRA_REPLY_TEXT</span>)</span><br><span class="line">		.setLabel(getString(<span class="type">R</span>.<span class="built_in">string</span>.replyLabel))</span><br><span class="line">		.build<span class="literal">()</span>).build<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<p><strong>Modify Activity to Use Reply Text</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bundle <span class="variable">results =</span></span><br><span class="line">	RemoteInput.getResultsFromIntent(intent);</span><br><span class="line">	<span class="keyword">if</span>(results!=<span class="constant">null</span>)&#123;</span><br><span class="line">	 String <span class="variable">message =</span> </span><br><span class="line">		results getString(EXTRA_REPLY_TEXT)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>3、最后我再来详细介绍下“多卡片重叠式信息提醒”的实现原理，视觉设计上采用的是复线收件箱的风格，ta不再把多条信息压缩到单一的卡片中，我们想做的是每封邮件都有自己的卡片。而这些卡片又放入一个可扩大的堆栈中，这一堆提醒卡片，也叫提醒卡片堆栈，也是notification API的新特性，不会把所有邮件提醒都只能通过一个提醒显示出来，而是按类划分，表明有所关联，ta们在可穿戴设备上组合成一个卡片丛，而用户也可以通过卡片丛去逐个浏览，以提取某一封邮件，并对其回复或者进行其他操作。而卡片丛 即：notification group也有一个分类键，通过设置这个键来控制丛内卡片顺序，并且可以从中标记一个卡片作为组群的整体摘要描述，具体实现代码如下：</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Notification</span> card1 = </span><br><span class="line">	<span class="keyword">new</span> <span class="type">NotificationCompat</span>.<span class="type">Builder</span>(context)</span><br><span class="line">		.setGroup(<span class="type">GROUP_KEY</span>)</span><br><span class="line">		.setSortKey(<span class="string">"0"</span>)</span><br><span class="line">		.build<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Notification</span> card2 = </span><br><span class="line">	<span class="keyword">new</span> <span class="type">NotificationCompat</span>.<span class="type">Builder</span>(context)</span><br><span class="line">		.setGroup(<span class="type">GROUP_KEY</span>)</span><br><span class="line">		.setSortKey(<span class="string">"1"</span>)</span><br><span class="line">		.build<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Notification</span> card3 = </span><br><span class="line">	<span class="keyword">new</span> <span class="type">NotificationCompat</span>.<span class="type">Builder</span>(context)</span><br><span class="line">		.setGroup(<span class="type">GROUP_KEY</span>)</span><br><span class="line">		.setSortKey(<span class="string">"2"</span>)</span><br><span class="line">		.build<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Notification</span> summary = </span><br><span class="line">	<span class="keyword">new</span> <span class="type">NotificationCompat</span>.<span class="type">Builder</span>(context)</span><br><span class="line">		.setGroup(<span class="type">GROUP_KEY</span>)</span><br><span class="line">		.setGroupSummar;</span><br><span class="line">		.build<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Hangouts">Hangouts</h3><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearhangouts.PNG" alt=""></p>
<ul>
<li>Hangouts Base On<ul>
<li>Custom Wearable Actions</li>
<li>Notification Pages</li>
</ul>
</li>
</ul>
<p>1、环聊信息也会自动桥接到可穿戴设备上，在Gmail上面，我们想要的是语音回复，但是环聊的提醒则稍微有点不同，ta并没有回复行为，只是一个内容意图，只需要打开App就可以键入回复了，所以环聊可以很好的不依赖手机而直接在可穿戴设备上进行体验，而且，android wear的 <code>Notification API</code>会让你在手机和可穿戴设备上细化不同的操作设置，即手机行为只在手机显示。wear行为只在wear端显示，这就使得我们可以添加一个仅限可穿戴设备使用的回复行为，这一行为涵盖了一个远程输入，却无需变动手机行为。</p>
<p>2、环聊也增加了新的提醒特征：近期会话历史记录。因为在语音回复之前，多出现一些聊天记录总是好的，为了实现这个效果，我们在wear设备扩充器中采用了添加页面的办法：它可以让你为主要提醒内容增加额外的页面，我们把聊天记录放入一个次级大的文本式提醒，然后把它加入到主要提醒中的第二页，并且手机端的提醒体验同时保持不变。关键代码实现如下：</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Notification</span> chatHistory =</span><br><span class="line">	<span class="keyword">new</span> <span class="type">NotificationCompat</span>.<span class="type">Builder</span><span class="literal">()</span></span><br><span class="line">		.setStyle(</span><br><span class="line">			<span class="keyword">new</span> <span class="type">NotificationCompat</span>.<span class="type">BigTextStyle</span><span class="literal">()</span></span><br><span class="line">				.bigText(getChatHistory<span class="literal">()</span>))</span><br><span class="line">		.build<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">firstPageNotification.extend(</span><br><span class="line">	<span class="keyword">new</span> <span class="type">NotificationCompat</span>.<span class="type">WearableExtender</span><span class="literal">()</span></span><br><span class="line">		.addPage(chatHistory)</span><br><span class="line">		.build<span class="literal">()</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Google_Camera">Google Camera</h3><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearcamera.PNG" alt=""></p>
<ul>
<li>Google Camera Base On<ul>
<li>Wearable DataApi </li>
<li>Wearable MessageAPI</li>
<li>WatchActivity </li>
</ul>
</li>
</ul>
<p>1、wear端的google camera为相机App增加了好玩有趣的特性：<strong>通过手腕来按下快门</strong>，和很多具有远程遥控的高级相机原理类似，你把手机架在三脚架上或者靠在墙上又或者让其他人帮你拿着，然后你通过按住腕表的一个按键来捕捉一个画面<strong>（代替现在正在热卖而很多大男生却不好意思在大街上用的自拍杆，嘿嘿）</strong>。</p>
<p>2、相比于前面提到的Gmail和环聊（ta们只是用了 <code>Notification API</code> 来对手机端的消息做一个整合），Google Camera是一个相对个性而又具有和手机交互的特点，而且对于wear来说，仅仅只需要将<strong>快门</strong>这个按键特殊处理就行，所以，在wear端，光快门按键就霸占整个屏幕这一点也是可以容忍的。</p>
<p>3、通过 <code>Google Play Service</code>(以后简称 <code>GMS</code>)，实现相机的wear端和手机端通信，在相机手机app准备好拍摄时，手机端端会设置好数据项（意味着它已经做好了接受远程快门信息的准备），这种数据项由手表中wear app内置的服务读取，而wear端则会显示出快门按钮，按住按钮，把信息发回手机来激活手机端的快门键，最后，如何预览你刚才拍到的照片呢？很简单：手机端会创建一张缩略图，然后作为数据项中的一个asset发送回手表端，然后做为wear端全屏来预览。<br>关键代码如下：</p>
<p><strong>Setting a DataItem</strong></p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PutDataMapRequest</span> dataMapRequest =</span><br><span class="line">	<span class="type">PutDataMapRequest</span>.create(<span class="type">DATA_ITEM_NAME</span>);</span><br><span class="line">dataMapRequest.getDataMap<span class="literal">()</span>.putBoolean(</span><br><span class="line">	<span class="type">FIELD_READY</span>,cameraReady);</span><br><span class="line"><span class="type">Wearable</span>.<span class="type">DataApi</span>.putDataItem(</span><br><span class="line">	mGoogleApiClient,</span><br><span class="line">	dataMapRequest.asPutDataRequest<span class="literal">()</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>WearableListenerService</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraListennerService</span></span><br><span class="line">	<span class="keyword">extends</span> <span class="title">WearableListennerService</span>&#123;</span></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="typename">void</span> onDataChanged(DataEventBuffer dataEvents)&#123;</span><br><span class="line">		<span class="keyword">for</span>(DataEvent <span class="string">dataEvent:</span>dataEvents)&#123;</span><br><span class="line">		    <span class="keyword">if</span>(dataEvent.getType()== 	DataEvent.TYPE_CHANGED)&#123;</span><br><span class="line">			DataMapItem mapDataItem = </span><br><span class="line">				DataMapItem.fromDataItem(</span><br><span class="line">					dataEvent.getDataItem());</span><br><span class="line">			<span class="keyword">if</span>(mapDataItem.getDataItem().getBoolean(FIELD_CAMERA_READY,<span class="literal">false</span>))&#123;</span><br><span class="line">			postNotification();</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		stopActivity();	</span><br><span class="line">	&#125;</span><br><span class="line">	)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Sending an Asset</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PutDataMapRequest dataMapRequest =</span><br><span class="line">	PutDataMapRequest.create(DATA_ITEM_NAME);</span><br><span class="line">dataMapRequest.getDataMap().putBoolean(</span><br><span class="line">	FIELD_READY,cameraReady);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在DataItem数据项中插入一个判断</span></span><br><span class="line"><span class="keyword">if</span>(previewBitmap != <span class="literal">null</span>)&#123;</span><br><span class="line">	dataMapRequest.getDataMap().putAsset(</span><br><span class="line">	 FIELD_PREVIEW,preview);</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Wearable.DataApi.putDataItem(</span><br><span class="line">	mGoogleApiClient,</span><br><span class="line">	dataMapRequest.asPutDataRequest()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="Google_Maps">Google Maps</h3><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearmaps.PNG" alt=""></p>
<ul>
<li>Google Maps Base On<ul>
<li>Voice Actions </li>
<li>Custom Display Intent Notifications</li>
</ul>
</li>
</ul>
<p>1、在Google Maps导航期间，我们想要在手腕上提示导航，这个应用场景在走路的时候尤其有用，因为你要一直拿着你的手机走在大马路上会非常奇怪且占用你的双手，如果把手机放在你的口袋，转而看一下手表的描述来获知导航信息无疑更为便捷和实用。</p>
<p>2、在wear端，google想实现对布局和导航呈现精细的把握，特地搭建了一款wear版本的google maps wear App，让个性抽取式卡片成为限于本地的提醒，通过修改google map手机app的数据项，增加了用于下一次操作的描述与图标以及用于解释导航状态的信息，同时wear端的google maps也增加了这样的数据项，每次变动发生后，ta都会读取新数据，然后更新wear的卡片，提取卡片时，wear app采用可穿戴扩充器的新显示意图特性，你可以指定一个活动来在提醒卡片中绘制内容，这样我们想在卡片上画什么都是可以的，而不是受限制于标准提醒样式。<br>关键实现代码：</p>
<p><strong>Custom Notification with Display Intent</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Intent displayIntent = </span><br><span class="line">	createUpdateIntent(data, maneuverBitmap);</span><br><span class="line">displayIntent.setClass(</span><br><span class="line">	<span class="keyword">this</span>,NotificationDisplayActivity.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">PendingIntent displayPendingIntent = PendingIntent.getActivity(</span><br><span class="line">	<span class="keyword">this</span>,<span class="number">0</span>,displayIntent,</span><br><span class="line">	PendingIntent.FLAG_CANCEL_CURRENT);</span><br><span class="line"></span><br><span class="line">Notification notification = builder.extend(</span><br><span class="line">	<span class="keyword">new</span> NotificationCompat.WearableExtender()</span><br><span class="line">		.setHintHideIcon(<span class="literal">true</span>)</span><br><span class="line">		.setDisplayIntent(displayPendingIntent)</span><br><span class="line">		.setBackground(background)</span><br><span class="line">		.addPage(secondPage)</span><br><span class="line">		.build();</span><br></pre></td></tr></table></figure>
<p>3、google map通过语音指令来开启导航进程，为了实现这一点，可<br>wear端的google map app会联手意图过滤器（ <code>Intent</code>）来为导航声音指令服务，然后需要在 <code>AndroidManifest.xml</code>中声明如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">	<span class="attribute">android:name</span>=<span class="value">".StarNavigationActivity"</span></span><br><span class="line">	<span class="attribute">android:theme</span>=<span class="value">"@style/TranslucentTheme"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="title">action</span></span><br><span class="line">		<span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">category</span>			<span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">data</span></span><br><span class="line">			<span class="attribute">android:scheme</span>=<span class="value">"google.navigation"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>声明之后，就会产生一个像这样的意图，可穿戴App接收到这个意图之后，就会给手机上的google map发送一条信息，信息包括目的地和导航模式，手机google map app接收到这条信息之后，然后开始导航到目的地，然后就可以出发了，具体通信代码如下:</p>
<p><strong>Sending a Message</strong></p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">private void startNavigation(Intent intent)&#123;</span><br><span class="line">	</span><br><span class="line">	String uriString = intent<span class="string">.getDataString()</span>;</span><br><span class="line">	</span><br><span class="line">	mGoogleApiClient<span class="string">.blockingConnect(</span></span><br><span class="line">		Constants<span class="string">.TIMEOUT_MS</span>,</span><br><span class="line">		TimeUnit<span class="string">.MILLISECONDS)</span>;</span><br><span class="line"></span><br><span class="line">	DataMap dataMap = new DataMap();</span><br><span class="line">	dataMap<span class="string">.putString(FIELD_URI</span>,uriString）；</span><br><span class="line"></span><br><span class="line">	Wearable<span class="string">.MessageApi.sendMessage(</span></span><br><span class="line">	   mGoogleApiClient,</span><br><span class="line">	   mOtherNodeId,</span><br><span class="line">	   Constants<span class="string">.MESSAGE_PATH_START_NAVIGATION</span>,</span><br><span class="line">		dataMap<span class="string">.toByteArray()).await()</span>;</span><br><span class="line">	googleApiClient<span class="string">.diconnect()</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>Receiving a Message</strong></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> onMessageReceived(</span><br><span class="line">	MessageEvent messageEvent)&#123;</span><br><span class="line">	<span class="keyword">if</span>(messageEvent<span class="built_in">.</span>getPath()<span class="built_in">.</span><span class="keyword">equals</span>(</span><br><span class="line">		MESSAGE_PATH_START_NAVIGATION))&#123;</span><br><span class="line">	  DataMap requestData <span class="subst">=</span></span><br><span class="line">			DataMap<span class="built_in">.</span>fromByteArray(</span><br><span class="line">				messageEvent<span class="built_in">.</span>getData());</span><br><span class="line">			<span class="built_in">String</span> uriString <span class="subst">=</span></span><br><span class="line">				requestData<span class="built_in">.</span>getString(FIELD_URI);</span><br><span class="line">			Intent navIntent <span class="subst">=</span> <span class="literal">new</span> Intent(</span><br><span class="line">				Intent<span class="built_in">.</span>ACTION_VIEW,</span><br><span class="line">				Uri<span class="built_in">.</span>parse(uriString));</span><br><span class="line">			startActivity(navIntent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="搭建云驱动的Android_Wear_Apps">搭建云驱动的Android Wear Apps</h1><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/djlblog_androidwear_cloud.JPG" alt=""></p>
<p>如图：</p>
<ul>
<li>1、首先，我们需要一款云服务来作为App的后端来进行数据推送和数据处理。</li>
<li>2、其次，移动App会配合这项服务发出一个提醒，而你会在wear设备上看到，而且该提醒也会发送到任何相连的AndroidWear设备上。</li>
<li><p>3、接着，当然就是AndroidWear App本身了，ta的特效是搭建在移动手机App之内，这样一旦手机App发出一条可以在手机上看见的提醒，这条信息也发给了Android Wear设备，现在的API也能够传送这些提醒，比如说触发回复行为，那么，我们是怎么实现ta们的呢？<code>Android Studio</code>实际上把你所需要的一切都给你了，包括用于搭建后端服务的工具包，当然还有Android手机App，现在你还可获得扩展包来操作Android Wear，云后端可以用一款外露的API来搭建，Android Studio工具包可以让你在Java下来进行此类操作，为你处理精细的细节把握，你可以写一段云端代码，通过使用属性，ta能够暴露出运行在你android app中的API，这些属性告诉Android客户端这些代码都是到底在干什么的，比如在执行一种叫quotesApi(引用API）时，并提供一种称为getQuote（获得引用）的方式，ok，一旦你现在搭建好了云服务，借助工具包，事实上你就可以自动创建客户端数据库来进入了，接下来，你要做的当然是搭建你的App了，那如何从你的App进入API呢？其实，这个分类已经自动帮你加载下来了，并且放入Maven库中了，这样你就可以直接在你搭建好的Gradle文件夹下涵盖它们了。</p>
</li>
<li><p>4、最后，我们如何把它拓展来用于Android Wear呢？ 其实很简单，跟google map中的例子一样，通过修改notification和卡片的代码，使用wear端的api，让消息提醒和前端信息视图同时展现在手机客户端和wear端，此时的<strong>手机App</strong>就<strong>变成了wear连接云端</strong>的<strong>中间件</strong>。</p>
</li>
</ul>
<h1 id="写给设计师们：如何把握Android_Wear下App的设计原则？">写给设计师们：如何把握Android Wear下App的设计原则？</h1><blockquote>
<p>PS：自己在DuWear项目组除了做RD研发之外，也对设计比较感兴趣，记得研发表盘那段时期，经常和搭档（MUX-UE-大侯）一起交流wear端的设计理念和心得，这里分享一些给想进军wear端的设计师朋友们：</p>
</blockquote>
<p><strong>首先我们需要知道的是：</strong></p>
<ul>
<li>Android Wear可以在多种不同的设备上运行，甚至在方形或圆形屏幕上也能正常运行，ta的UI非常简单，而且显示的内容也做了优化以适应小屏幕。</li>
<li>Android Wear的核心UI会自动排列卡片的优先级，非常简单，它整合了像Google Now，安卓手机提醒（Notification）和关联性App等资源，从而可以直接在wear端运行，开发师可以创建可以在这种流中正确显示的卡片，在任何点上，我都可以朝左滑动来查看每个项的更多信息，朝右滑动则会移除卡片，</li>
<li>我们也给里面加入了向谷歌说话的能力，用户只需说一句：OK Google来搜索网络寻求答案，也可以进行我们称之为行为（actions）的语音指令，开发师可以深入开发这些语音行为。意味着用户可以直接对你的软件说话。</li>
<li>可穿戴设备提供了一套前所未有的设计理念，<br>这即是机会，也是挑战，所以相对其他诸如手机或平板之类的设备，要清楚明白地搞懂它们之间的不同之处非常重要。<br>Android Wear刚好在正确的时间提供了正确的信息，让人们同时与虚拟和现实世界有更好的联系，信息内容会尽可能自动显示在信息流中，对于早已习惯打开App和退出App的我们来讲，这种对于模块的变化是相当巨大的。<h2 id="设计思路：">设计思路：</h2></li>
<li><p><strong>Contextual：</strong>Android Wear会注意到周围环境，而且十分智能，这些设备会让人与计算机设备的亲密关系全新升级，Android Wear不要求用户的关注与输入，相反它会注意到用户所处的环境与状态，然后在正确的时间体贴地提供正确的信息，Android Wear会让人感觉信息及时，提议中肯，无微不至。</p>
</li>
<li><p><strong>Glanceable：</strong>这些App只需要一瞥的时间，不算是可穿戴设备处于我们的视线边缘，它们也可以整天使用，高效的App会用最小的嗡嗡声来提供更多的信息提醒，并在细碎的关联信息提醒上做进一步优化，从而在一整天的碎片时间里得以应用。</p>
</li>
<li><p><strong>Low Interaction：</strong>快速思考，一针见血，迅捷即时，而且几乎不用与设备互动，在保证小屏幕传送信息优势的同时，Android Wear着重与简单的互动，仅仅在非常必要的时候来需要用户来输入。而且绝大多数输入都是简单的点触、滑动和语音指令，而一般输入所需要的精细操控也得以避免。Android Wear手势简单，操作便捷而迅速</p>
</li>
<li><p><strong>Suggest&amp;Demand：</strong>最后，这些体验都与建议和指令相关，Android Wear就像一位出色的个人助理，它了解你，知道你的喜好，只有在绝对必要的时候才会打扰你，而且它总是近在手边，随时准备为你回答或完成任务。Android Wear贴心、礼貌、有问必答，它把周围世界与用户巧妙联系起来的同时，又极其尊重你的注意力，把你的焦距汇到重点项目上。</p>
</li>
<li><strong>Break It Down：</strong>这里所呈现的机会并不是想象中的那样——把智能手机的UI缩小一下就塞进来,相反，需要考虑的是在设计过程中出现的基础性的问题，遵循这些原则之后，要是用户在使用你的产品操作任务时，产品出问题了怎么办？</li>
</ul>
<p>接下来，我们来看一些<strong>出色的设计案例</strong>：</p>
<ul>
<li><strong>Stream Apps</strong></li>
</ul>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearstreamapps.PNG" alt=""></p>
<p> 如图，系统中众多App的展现体现在那些垂直的卡片流之中，让小小的屏幕可以为用户尽可能多得展现更多的Wear应用，也是用户界面的核心所在。</p>
<ul>
<li><strong>Main Interface</strong></li>
</ul>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearcarddesigner.PNG" alt=""><br><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidweargooglenowcard.PNG" alt=""></p>
<p> 如图，这里我们看到主屏幕流中有一些卡片，像这种卡片就会在特定时刻，需要它们该出现的时候才出现。就像 <code>Google Now</code>一样，这些卡片无需启动或打开，相反，ta们会基于所在地、走路或者奔跑等活动、实际时间、用户的兴趣爱好以及其他因素来运行，你可以指定某项内容在合适的时候出现，这些卡片与环境息息相关，要注意看这些内容十分简洁，而且布局十分清楚，这些布局也经过了优化，让人能通过<strong>眼角一瞥就能一目了然</strong>。这些卡片也会遵循我们低互动（Low Interaction）的原则，它们没有大量的目录和按钮，用户可以直接滑动屏幕来进入另一页获取更多资料，事实上，通过Android Wear用户界面你应该使用像<strong>滑动和全屏挥动</strong>这样的大手势，不要在一个屏幕上放置多个需要点击的小按钮。</p>
<ul>
<li>更多Android Wear出色案例和设计资源请参考下文中的：<a href="">更多系列教程</a></li>
</ul>
<h1 id="Android_Wear搭建更高级别的UI">Android Wear搭建更高级别的UI</h1><p>可穿戴设备的App是Android的标准App，但遵循的是小屏幕的设计理念，它们全屏运行，没有系统UI或状态条，它们的开发过程与安卓App类似，不过在UI的开发理念上却稍有不同，最重要的就是要记住你的界面不必苛求小点触屏或精准的拖拽，举个例子，在可穿戴系统UI中，你会注意到对滑动操作的频繁使用，还有滚动条的运用，它之所以能够流畅运行，是因为它并不需要把注意力花在要去触摸屏幕某个精准的点上，为了帮助大家，Google提供了一个<a href="http://developer.android.com/training/wearables/ui/index.html" target="_blank" rel="external">可穿戴设备App的UI库</a>，它提供了异常丰富的元素来用于UI的设计。</p>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidweargradpagerview.PNG" alt=""></p>
<p>这里，我想重点讲一下 <code>GridViewPager(网格多面控件)</code> ,ta与主页流类似，大家可以用ta来设计界面，ta与多面控件相似，但是可以水平和垂直同时移动，第一步就是布局的规划，下面这几行代码就是你主行为所需要的全部内容：</p>
<p><strong>res/layout/pager_example.xml</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml <span class="variable">version =</span> <span class="string">"1.0"</span> <span class="variable">encoding =</span> <span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;android.support.wearable.views.GridViewPager</span><br><span class="line">	xmlns:<span class="variable">android =</span> <span class="string">"http://schemas.android.com"</span></span><br><span class="line">	android:<span class="variable">id =</span> <span class="string">"@+id/pager"</span></span><br><span class="line">	android:<span class="variable">layout_width =</span> <span class="string">"match_parent"</span></span><br><span class="line">	android:<span class="variable">layout_height =</span> <span class="string">"match_parent"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，配置多面控件的目的是用于扩展至整个屏幕的，下一步，我们需要一个衔接器（<code>Adapter</code>）</p>
<p><strong>FragmentGridPagerAdapter</strong></p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> getRowCount<span class="literal">()</span></span><br><span class="line"><span class="built_in">int</span> getColumnCount(<span class="built_in">int</span> row)</span><br><span class="line"><span class="type">Fragment</span> getItem(<span class="built_in">int</span> row , <span class="built_in">int</span> column)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> getCurrentColumnForRow(</span><br><span class="line">	<span class="built_in">int</span> row,<span class="built_in">int</span> currentColum)</span><br></pre></td></tr></table></figure>
<p>而这几行代码则是在用户使用导航时为用户提供每张页面所呈现的内容，在这个例子中，我会从一个由片段支持的基本类来进行扩展，要创建一个运行的<code>Adapter</code>只需要这三个方法，前两种定义了内容行（<code>row</code>）与页的可用大小，注意 <code>column</code> 的数量取决与行参数<code>row</code>,原因就在于每行可能都有不同的列数量，它的特性就是其选项可以控制每行在页面哪个位置来放置，与固定好的网格布局相比，它给滚动条在平等滚动与垂直滚动间切换提供了可能，在这一布局中，为了实现这点，Google还想了一些办法，但结果看起来就是一个无缝对接，Google为什么要这么做？Google认为每行内容都是单独的存在，在主页流中，这些就成了提醒或Google Now卡片，用户要从一个行为页进入到目标页而进行上下滑动的操作时，如果有不同的项，那么用户在操作时就会迷惑，为了解决这个问题，上翻或下翻总会回到第一列，这个也是网格多面控件的默认模式，为了对此做出调整，你可以用另一种方式进行覆盖，这种方式称为：所想即所见（用户想了解某项信息时，该信息的页面就会呈现在当前页或下一页），它也会提供当前列的位置，为了返回固定的移动系统，你可以选择返回列，或许你还想保存该行上次浏览的那一列，以便下次选择改行时可以直接返回到那一列。最后，最重要的一点就是getItem了，这个就是你要在页面上呈现出片段的位置了，这里，你只需要返回到你的内容片段，然后剩下的事情就由多面控件来处理了。只要需要，内容片段可以长久存储，然后在合适的时候，要么删除，要么重新进入，在这种方式跟多面控件非常类似，只是加了一个垂直的维度而已。</p>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/androidwearcontentPage.PNG" alt=""></p>
<p>为了帮助大家建立自己的页面内容，Google提供了卡片内容片段，它可以自动应用不同的风格,从而与系统卡片搭配一致，而你要做的只是提供内容就可以，这种内容片段也有许多附加特性，首先，如果你有超过一页的内容，它就会显示滚动条让你拖动到正确的位置，你也可以让它作为一个单独页面开始，这样就可以通过触按来放大到全屏了，在这个案例中，内容溢出会自动得到处理，在你代码样本和文档中会找到更多细节的，还有一些事情要记住：每个页面尽量只放一个单独的行为，如果可能的话，整张卡片应该做成一个触按目标，而需要运行的行为则应该清楚明白，现在，剩下需要做的就是把这些东西整合起来，转接类会处理所有内容片段操作,所以需要给片段管理来一个参数，把转接代码加入到页面代码中就行了。</p>
<p><strong>SampleActivity.java</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">	 setContentView(R.layout.pager_example);</span><br><span class="line">	 mPager = findViewById(R.id.pager);</span><br><span class="line">	 mAdapter = <span class="keyword">new</span> ExampleGridPagerAdapter(getFragmentManager());</span><br><span class="line">	 mPager.setAdapter(mAdapter);	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Android_Wear_数据层API_DevBytes">Android Wear 数据层API DevBytes</h1><p>首先我们需要知道手机端和wear端的连接是基于Android Wear数据层API的，一旦出现任何变化，核心数据层API会让你的掌上设备，与可穿戴设备自动同步数据，这种进程能够让你的设备充当数据发送器或接收器，或兼而有之，发送器设备设置一些准备发送的数据，一旦这些数据发生变动，那么这些变动就会发送给接收器，接受数据的设备反过来会在检测变动之后，会启动一个反馈功能来告诉程序数据已更新，处于两种设备之间的核心对象被称为<strong>数据项</strong>，它能有效提供设备所需要的数据存储，从基础面来讲，数据项包含一个有效负载对象，它是用来负载实际的数据的，还有一个是路径对象，它为数据项提供唯一的标识符字符串，它在接收端很重要，来表明具体哪些数据得到了更新。</p>
<p>数据项能在可穿戴设别与掌上设备间来回接受和发送小批量数据，例如使用可穿戴设备传感器来收集心率信息，并发送到用户的手机，与前14周的心率信息交叉想比较，并将结果图反映在手表上，因为电流限制的原因，数据项对象能承载小部分数据大约有100k，因此如果你希望数据项承载更大的数据量，你需要附加一个超大容量的对象，这样你就能发送大量的二进制数据到蓝牙传输，如图像，举个例子吧，用掌上设备应用软件下载一个图像，调整大小，然后发送到穿戴式设备上进行展示，掌上设备负责进程中所有的复杂的重量级操作，而穿戴式设备则呈现简单的结果，很不错的是，为了避免数据的重发，资产对象负责缓存数据和保存蓝牙带宽，这就意味着每个缓存的资产对象只能对应一种情况，如果你重复发送多次，也不会浪费带宽或者是电量，更简单的方面，数据有效载荷API也能提供信息API，这样就能完成普通任务，例如告知你的穿戴设备要执行<code>Activity</code>，或者是提醒手机切歌曲，在默认的情况下，这些信息可以通过远程过程调用，也就是说，一旦过程改变，则不能确保信息能被接收，但是如果你想要程序更复杂，可以将信息设置成提问（<code>request</code>）或回答（<code>response</code>）的形式，这样连接的另一方就会告知另外的设备，反过来，另外的设备会完成相关的工作，然后做出回答，相应地，提交答复。更多复杂的DataAPI细节可以到google android developer官网查看。</p>
<h1 id="Android_Wear的提醒（Notification）新特性">Android Wear的提醒（Notification）新特性</h1><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/github_androidwear23.png" alt=""></p>
<p>我们来看看wear设备提醒的三个新方面吧：</p>
<ul>
<li>新的显示选项</li>
<li>新的提醒行为</li>
<li>高级自定义设置</li>
</ul>
<p>这是一个提醒流，它能很好地获取信息并与用户交互，这里有不同外观不同尺寸的垂直提醒列表，获取信息时只需要向上滑动一下表盘就能办到，继续滑动的话就会显示出额外的卡片，信息流中的这些提醒会加入到安卓提醒API中去，如果你已经熟悉了这个API，你可能就会识别出它的一些特性了，比如在独立的屏幕上会出现正确的提醒行为，但跟平板对于手机类似的是，提醒是依然可以被取消的，只需要把提醒卡滑到边上然后释放即可，手机上的提醒会自动同步到你的手表上面，这可以让许多现有安卓APP来在可穿戴设备上发挥自己的价值，它们也可以增加行为和撤销，我们<strong>支持许多现有的提醒风格</strong>，比如<strong>收件箱式、大图式和长文本式</strong>，如果内容太长，用户可以按住提醒来扩展，为了让体验更加丰富，我们也增加了新API来自定义提醒，TA们就成了AndroidSDK和libs库中可穿戴设备扩展类的一部分了。</p>
<p>首先我们来看看，多页面提醒设计<code>Multi-page notifications</code>：</p>
<h2 id="多页面提醒设计（Multi-page_notifications）">多页面提醒设计（Multi-page notifications）</h2><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmutinotifi.PNG" alt=""></p>
<p>这些页面可以进一步为单条提醒增加详细信息，通过滑动就可以进入，屏幕下方的提示会让你知道TA们停留在哪个片面上，因为页面仅仅是提醒对象，所以他们可以使用任意的提醒风格，</p>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmutinotifi2.PNG" alt=""></p>
<p>要给一条提醒增加页面的话，使用可穿戴设计新拓展类来增加页面，如下代码段为内容增加了两页新页面：</p>
<p><strong>Add pages to a notification</strong></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Notification page2 <span class="subst">=</span> <span class="attribute">...</span></span><br><span class="line">Notification page3 <span class="subst">=</span> <span class="attribute">...</span></span><br><span class="line"></span><br><span class="line">NotificationCompat<span class="built_in">.</span>Builder builder <span class="subst">=</span> <span class="attribute">...</span></span><br><span class="line">builder<span class="built_in">.</span>extend(</span><br><span class="line">   <span class="literal">new</span> NotificationCompat<span class="built_in">.</span>WearableExtender(</span><br><span class="line">	<span class="built_in">.</span>addPage(page2)</span><br><span class="line">	<span class="built_in">.</span>addPage(page3)</span><br><span class="line">	<span class="built_in">.</span>setBackground(bitmap)<span class="comment">//设置位图</span></span><br><span class="line">	<span class="built_in">.</span>setHintShowBackgroundOnly(<span class="literal">true</span>));<span class="comment">//隐藏图片</span></span><br><span class="line">NotificationManagerCompat<span class="built_in">.</span>from(ctx)</span><br><span class="line">	<span class="built_in">.</span>notify(builder<span class="built_in">.</span>build());</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>总计就是三张卡片了，此外，你可以添加一张全屏图像作为页面，就用不着卡片了，这种办法对地图或照片之类的内容来说非常实用。</p>
<h2 id="提醒堆栈（Notification_Stacks）">提醒堆栈（Notification Stacks）</h2><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblognotifistack.PNG" alt=""></p>
<p>它可以把多条提醒归类成一组，用户可以与整个堆栈交互，也可以进入到单独的项中，堆栈本身及子提醒也可以增加行为，这个特性对信息型APP来说非常方便，因为用户可能会一次性查看所有信息，或只看其中的一条，为了创建提醒堆栈，推送一条或多条子提醒，然后把它们全打上组密钥的标签，你可以采用<code>NotificationCompat.Builder</code>中的<code>setGroupMethod</code>（设置组方式）来实现这一点。来自同一APP相同组密钥的提醒推送会被归类到同一堆栈中，你也可以使用setSortKey(设置类密钥)来处理项，如果你喜欢为一个丛（<code>bundle</code>）选择背景图片和行为，你可以推送一个可选择的组概要提醒，在下面代码中，用户会看到为丛设置的“全部归档”行为，取保为每个提醒选择一个唯一的提醒ID或标签，以免它们在推送时会相互覆盖。</p>
<p><strong>Post group child notifications</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//<span class="keyword">for</span> each child notification</span><br><span class="line">NotificationCompat.Builder builder = ...</span><br><span class="line">build.addAction(R.drawable.archive,</span><br><span class="line">	<span class="string">"Archive"</span>,pendingIntent)</span><br><span class="line">	.<span class="built_in">set</span>Group(<span class="string">"my-group"</span>)</span><br><span class="line">	.<span class="built_in">set</span>SortKey(<span class="string">"sort-key"</span>);</span><br><span class="line">NotificationManagerCompat.<span class="keyword">from</span>(ctx)</span><br><span class="line">	.notify(builder.build());</span><br></pre></td></tr></table></figure>
<p>目前展示的提醒行为全部使用了默认设置，可以作为附加页面增加到相应卡片之中，下图左手的手表展示了这一设置,把主卡滑走就出现了“播放”行为，右手的手表则展示了直接把行为添加进当前卡片的行为，这样这张卡片就可以直接点击了，使用可穿戴扩展器中的setContentAction(设置内容行为)来为卡片添加行为。这些行为就不会作为单一页面来显示了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Action Notification</span></span><br><span class="line">NotificationCompat<span class="class">.Builder</span> builder = ...</span><br><span class="line">build.<span class="function"><span class="title">addAction</span><span class="params">(R.drawable.pause,<span class="string">"Pause"</span>,intent)</span></span></span><br><span class="line">build.<span class="function"><span class="title">extend</span><span class="params">(new NotificationCompat.WearableExtend)</span></span></span><br><span class="line">	.<span class="function"><span class="title">setContentAction</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmusicstatus.PNG" alt=""></p>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmusicstatus0.PNG" alt=""></p>
<h2 id="远程输入（Remote_Input）">远程输入（Remote Input）</h2><p>远程输入则是提醒行为的另外一个新特性，在激活一个行为时，它可以让用户开启文本回复，设备会提供给用户一个短语或让用户从一些选项中进行选择，这种输入的结果就是将含有你意图的行为发送了出去，通过远程输入，AndroidWear与手机、平板或可穿戴设备的APP互动就变得非常简单了，下面的代码就显示出我们为回复行为增加了一个远程输入，用户在卡片流中点击这一行为时，系统就会在<code>Quick Reply</code>的标签下，提供给用户一个语音回复的行为，一旦文本回复转换完成而又得到了用户的同意，你的行为意图就会发出，而且目的已经包含在内了，</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="subst">**</span>Add RemoteInput <span class="keyword">to</span> a notification action<span class="subst">**</span></span><br><span class="line"><span class="built_in">String</span> EXTRA_QUICK_REPLY <span class="subst">=</span> <span class="string">"quick_reply"</span>;</span><br><span class="line"></span><br><span class="line">NotificationCompat<span class="built_in">.</span>Builder builder<span class="subst">=</span><span class="attribute">...</span></span><br><span class="line">builder<span class="built_in">.</span>addAction(</span><br><span class="line">	<span class="literal">new</span> NotificationCompat<span class="built_in">.</span>Action<span class="built_in">.</span>Builder(</span><br><span class="line">		R<span class="built_in">.</span>drawable<span class="built_in">.</span>reply,<span class="string">"Reply"</span>,pendingIntent</span><br><span class="line">	<span class="built_in">.</span>addRemoteInput(</span><br><span class="line">		<span class="literal">new</span> RemoteInput<span class="built_in">.</span>Builder(EXTRA_QUICK_REPLY)</span><br><span class="line">			<span class="built_in">.</span>setLabel(<span class="string">"Quick reply"</span>)<span class="built_in">.</span>build())</span><br><span class="line">		<span class="built_in">.</span>build());</span><br><span class="line"></span><br><span class="line"><span class="attribute">...</span></span><br></pre></td></tr></table></figure>
<p>你的意图接收器，可以是一个<code>Activity</code>，<code>Service</code>，<code>Broadcast</code>，就可以使用远程输入API意图功能中的<code>Get Results</code>，来重新恢复成目的文本了，在下面的代码中，quickReplyText变量会根据用户的输入来进行设置，在远程输入API中还有许多其他选项可以使用，支持的内容包括预设选择、允许或禁用、自由样式输入，还支持同一行为的多种输入等。</p>
<p><strong>MyActivity.java</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	Bundle results = RemoteInput.getResultsFromIntent(</span><br><span class="line">		getIntent());</span><br><span class="line">	<span class="keyword">if</span>(results != <span class="keyword">null</span>)&#123;</span><br><span class="line">		CharSequence quickReplyText = </span><br><span class="line">			results.getCharSequence(</span><br><span class="line">				EXTRE_QUICK_REPLY);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Custom_Display_Cards">Custom Display Cards</h2><p>标准的提醒模版或许并不足以展示你想在卡片中出现的内容，所以我们增加了一个API：set Display Intent（设置显示意图），它可以让你使用安卓活动来实时绘制提醒内容，这一特性只对可穿戴设备上运行的APP可用，而且这些APP所用的API需要20以上的版本，定义内嵌到自定义显示卡片的活动时，你必须首先把它标记为exported（导出），这个可以通过在活动中设置导出属性为true，或增加一个意图过滤器来完成，接下来，把这一新属性的“是否潜入”设置为true，这样可以防止活动嵌入到不该嵌入的事件中去，最后，设置关联任务<code>task Affinity</code>为空字符串，虽然触控输入并不会在信息流中传播，但这些活动与其他活动一样，可以包含相同内容，这样像按钮那样的控制就可能不再适合了，你的活动写入之后，你可以将其嵌入到信息流中来创建一条提醒，然后使用可穿戴扩展器中的<code>setDisplayIntent</code>（设置显示意图）方式来选择该活动，你可以为显示意图增加附加内容来通过活动所需要的任何数据。</p>
<p><strong>AndroidMainifest.xml</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">	android:<span class="variable">name=</span><span class="string">"com.example.MyDisplayActivity"</span></span><br><span class="line">	android:<span class="variable">exported=</span><span class="string">"true"</span></span><br><span class="line">	android:<span class="variable">allowEmbeded=</span><span class="string">"true"</span></span><br><span class="line">	android:<span class="variable">taskAffinity=</span><span class="string">""</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>下面就是自定义显示提醒的一些模版，信息流中的标准提醒会基于内容自动调整大小，但是自定义显示提醒则需要在不想要默认大尺寸的情况下提供一个尺寸，你可以使用可穿戴拓展器中的设置自定义尺寸预设，或是设置自定义内容高度等方式来选择尺寸。</p>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblognotifiwearmoban.PNG" alt=""></p>
<h2 id="Notification_Bridging">Notification Bridging</h2><p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogmobile_wear_noti.PNG" alt=""></p>
<p>通过设置这些自定义卡片，之前上面提到的<code>Notification API</code>可以同时用在可穿戴设备的APP的提醒创建，以及来自手机或平板APP上的提醒桥接，桥接过程在可穿戴设备上是自动进行的，但是这里还有<strong>几种新API是用来自定义桥接行为的</strong>，如下代码所示：首先，你可以使用提醒兼容设置中的新<code>set Local Only</code>（设置仅本地）来完全禁用提醒桥接，如果一个提醒仅相关当前设备，那它就很有用处了，第二个特效，就是增加提醒仅可穿戴设备可用的行为，它可以让你为手机和可穿戴设备选择单独的行为设置，仅可穿戴可用行为在可穿戴扩展器的类中添加。</p>
<p><strong>Disable bridging for a notification</strong></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">NotificationCompat</span>.<span class="variable">Builder</span> builder = ...</span><br><span class="line">builder.set<span class="variable">LocalOnly</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Add an action for phones,tablets,and wearables</strong></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">NotificationCompat</span>.<span class="variable">Builder</span> builder = ...</span><br><span class="line">builder.add<span class="variable">Action</span>(<span class="variable">R</span>.drawable.reply,<span class="string">"Archive"</span>,pending<span class="variable">Intent</span>);</span><br><span class="line">	.add<span class="variable">Action</span></span><br></pre></td></tr></table></figure>
<p><strong>Add an action for wearables only</strong></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NotificationCompat<span class="built_in">.</span>Builder builder <span class="subst">=</span> <span class="attribute">...</span></span><br><span class="line">builder<span class="built_in">.</span>extend(<span class="literal">new</span> NotificationCompat<span class="built_in">.</span>WearableExtender()</span><br><span class="line">	<span class="built_in">.</span>addAction(<span class="literal">new</span> NotificationCompat<span class="built_in">.</span>Action(</span><br><span class="line">		R<span class="built_in">.</span>drawable<span class="built_in">.</span>reply,<span class="string">"Reply"</span>,pendingIntent)));</span><br></pre></td></tr></table></figure>
<p>PS：这里有博主自己曾经写过的一个运行在Android手机上的Demo，用来展示Wear端的Notification新特性:<a href="https://github.com/AndroidWearDemo/AndroidWearNotification" target="_blank" rel="external">在Github上获取</a></p>
<p>也可以参考国外大神的一个例子：<a href="http://code.tutsplus.com/tutorials/enhanced-and-wearable-ready-notifications-on-android--cms-21868" target="_blank" rel="external">Enhanced and Wearable-Ready Notifications on Android</a></p>
<h1 id="Android_Wear下的全屏App设计理念">Android Wear下的全屏App设计理念</h1><p>为Android Wear设计APP的许多技术因素，你们会觉得非常熟悉，因为它们跟普通的Android APP运行原理是一样的，不过呢，这里主要讲的是<strong>两大不同点</strong>：</p>
<h2 id="让用户如何退出APP">让用户如何退出APP</h2><p>在手机或平板上，用户会使用返回或主页键来推出APP，但这些按钮在Android Wear设备上都不会出现，相反，在wear app上，用户离开你的APP会有如下两种办法：<strong>一种是把页面朝左滑动至边缘退出，另一种是长按APP退出</strong>：</p>
<h3 id="滑动退出：">滑动退出：</h3><p>通过Android Wear我们引入了一种新的窗口属性：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; style <span class="property">name</span> =<span class="string">"AppTheme"</span> parent = <span class="string">"Theme.DeviceDefault"</span> &gt;</span><br><span class="line">	&lt; <span class="property">item</span> <span class="property">name</span> = <span class="string">"android.windowSwipeToDismiss"</span>&gt;<span class="constant">true</span>&lt; /<span class="property">item</span> &gt;</span><br><span class="line">&lt; /style &gt;</span><br></pre></td></tr></table></figure>
<p><strong>即窗口滑动属性</strong>，这种窗口属性可以运用在你具体的活动主题中，一旦窗口滑动退出属性设置为true，那么活动一旦从左滑动至右，它就会退出，这种滑动退出运行方式跟多面控件运行方式类似，如果活动中的内容本身就可以滚动，那么窗口就不会退出，除非用户滚动到该内容边缘后再次滑动，它可以让你创建一些非常出色、类似信息流的体验，这些体验也可以通过滑动来退出。所有的Android Wear APP要么使用设备默认主题，要么使用一个继承默认设备的主题，这样可以确保不同的主题风格都会在你的APP上正常运行，从而让它们在你的wear设备上看起来非常好，</p>
<p><strong>You get it by default</strong></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">	android:name=<span class="string">".ControlRobotsActivity"</span></span><br><span class="line">	android:theme=<span class="string">"Theme.DeviceDefault"</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">当然，我们知道，有些<span class="keyword">APP</span>没办法使用滑动退出的功能，比如，无限移动的地图应用时永远没有边缘的，如果你不想使用滑动手势，那么你可以通过吧滑动的退出属性设置为false，来在你的主题中禁用<span class="keyword">ta</span>。对于无法通过滑动来退出的<span class="keyword">APP</span>。我们可以使用第二个属性：即**长按退出功能。**</span><br><span class="line">    </span><br><span class="line">### 长按退出 ###</span><br><span class="line">这就相当于是一个退出按钮的行为了，为了让用户知道你的<span class="keyword">APP</span>可以长按退出，在<span class="keyword">APP</span>首次运行时，你要给用户一个长按退出的提示。打开我们的wear设备，你会发现在屏幕任何地方出现长按行为，都会在<span class="keyword">APP</span>上出现一个退出按钮。再按下那个按钮来退出活动，用户则会回到主页，为了让你的<span class="keyword">APP</span>退出变得尽量容易，Google做了一个可以在大多数UI上运行的<span class="keyword">View</span>,它叫退出覆盖视图（dismiss overlay <span class="keyword">view</span>）</span><br><span class="line">     </span><br><span class="line"><span class="comment">**activity_control_robots.xml**</span></span><br></pre></td></tr></table></figure>
<android.support.wearable.view.dismissoverlayview android:id="@+id/dismiss_overlay" android:layout_height="match_parent" android:layout_width＝"match_parent"="">    

<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了把它集成到你的APP中，首先要把它添加进你的XML活动层中，确保它<span class="keyword">*</span><span class="keyword">*</span>增加的位置一定是在其他布局之上的<span class="keyword">*</span><span class="keyword">*</span>你还要确保该视图的尺寸能够覆盖整个屏幕，把它高度和宽度设置成与父框架相匹配，这样它就能够确保全屏，而且处于最顶层了，现在我们来看看java类里面怎么写：</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>ControlRobotsActivity.java<span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure>
<p>public void onCreate(Bundle savedState){<br>    super.onCreate(savedState);<br>    setContentView(R.layout.activity_control_robots);</p>
<pre><code>mDismissOverlay = (DismissOverlayView)findViewById(R.id.dismiss_overlay);
mDismissOverlay.setIntroText(R.<span class="built_in">string</span>.long_press_intro);
mDismissOverlay.showIntroIfNecessary();

 mDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>,<span class="keyword">new</span> SimpleOnGestureListener(){
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent ev)</span></span>{
       mDismissOverlay.show();
   }

 });
}
</code></pre><p>…</p>
<p>@Override<br>public boolean onTouchEvent(MotionEvent ev){<br>    return mDetector.onTouchEvent(ev) | | super.onTouchEvent(ev);<br>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在它的<span class="escape">`o</span>nCreate<span class="escape">`中</span>把退出层从你的布局层中拉出来，然后设置为内省文本，这个文本会在第一次运行活动时显示出来，而且会显示在APP其他内容之上，用来告诉用户可以通过长按来返回主页，然后，使用<span class="escape">`s</span>howIntroIfNecessary<span class="escape">`(</span>必要时显示内省文本)，它会，也只会在第一次运行该APP时显示这个内省层，，接下来，如果用户长按了你的app，我们就需要让它激活，使用<span class="escape">`G</span>estureDectector<span class="escape">`(</span>手势检测器）和<span class="escape">`S</span>impleOnGestureListener<span class="escape">`（</span>简易手势接收器）,使用这些框架类会确保所有app感应到手势的时长，在你长按返回时，会激活布局层显示退出行为，会显示一个退出按钮，如果用户点击了该按钮，你的活动就会被结束，但如果你没有点击该按钮，那么这个退出层就会自行隐藏，等着下次出现的命令，最后，还是在你的活动中覆盖一层 <span class="escape">`o</span>nTouchEvent<span class="escape">` </span>(触控事件)，然后让<span class="escape">`r</span>eveiveTouchEvents<span class="escape">` </span>(接受触控事件)连通到<span class="escape">`G</span>estureDectector<span class="escape">`（</span>手势检测器）,如果 <span class="escape">`G</span>estureDetector<span class="escape">` </span>返回为<span class="literal">true</span>，你也真的返回主页了，而且不用触动 <span class="escape">`o</span>nTouchEvent<span class="escape">` </span>方式的正常活动,相反如果为<span class="literal">false</span>，那就可以继续使用正常活动的触控。</span><br><span class="line"></span><br><span class="line">## 如何设计和运用你的APP，让ta看起来在圆形屏幕(Moto <span class="number">360</span>)上很不错。 ##</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="label">![](http:</span>//<span class="number">7</span>xi6qz.com1.z0.glb.clouddn.com/github_myblogmoto360_size.PNG)</span><br><span class="line"></span><br><span class="line">首先，我们来看看<span class="number">360</span>的屏幕维度吧，这是一个直径为<span class="number">320</span>px的圆圈，下方有<span class="number">30</span>px的<span class="escape">`c</span>hin<span class="escape">`，</span>因此系统会认为它的尺寸为<span class="number">320</span>x290px，在我们自己开发的过程中，我们意识到chin会将一些非计划中的结果导入到现有的布局中，比如我们来看一下信息流中的行为卡片，我们希望给屏幕中央放置一个行为图标，但我们给中央垂直点加了一个层重力机制之后，结果这个蓝圆偏移了<span class="number">15</span>px，但我们还是希望中间的这个蓝圆最好能够处于整个屏幕的中央，在我们之前提到过的默认主题中，<span class="escape">`w</span>indowOverscan<span class="escape">`属</span>性已经设置了，而且整个视图分级结构的源是<span class="number">320</span>X320px，这就导致了你的APP顶级结构视图，依然认为是<span class="number">320</span>X320，而非<span class="number">320</span>X290，然后再把你的局布如预想般放在屏幕中央，如何检测你的活动是运行在圆形屏幕中的呢？你的视图会请求应用窗口插入<span class="escape">`i</span>nsets<span class="escape">`,</span>然后会返回一个窗口插入目标，它会告诉你屏幕的形状，在Moto360中，它会告诉你下方插入的窗口为<span class="number">30</span>px，在任何地方只要你要围绕这个<span class="escape">`c</span>hin<span class="escape">`来</span>布局，你就需要经常使用这个值，这里所使用的插入值，会确保你的APP在以后任何可穿戴设备上看起来都很漂亮，为了节省大家敲打这些通用代码的时间，Google增加了一个叫<span class="escape">`W</span>atchViewStub<span class="escape">`的</span>视图，它可以让你根据APP运行的不同屏幕来扩充一两种不同的布局，如果你想在屏幕上看起来与众不同，就可以使用<span class="escape">`W</span>atchViewStub<span class="escape">`来</span>作为任何视图分级就够的源，要使用的话，先在你的活动或者onCreate碎片中创建一个新的源，完成之后，你就需要给你的源加上两层布局（<span class="escape">`R</span>ound、Rect<span class="escape">`）</span>,但是有一个问题需要注意：因为这些布局在视图在附加进结构分级前，并没有进行扩充，你就没办法进入子一级的视图，相反，附加一个OnLayoutInflatedListener(布局扩充收听器)，它可以在布局内层进行不合适的扩充时使用，退出布局视图和这个WatchViewStub都可以在可穿戴支持库<span class="escape">`W</span>earable Library<span class="escape">`中</span>找到，如下：</span><br></pre></td></tr></table></figure></p>
<p>public WindowInsets onApplyWindowInsets(View view,WindowInsets windowInsets){<br>    if(windowInsets.isRound()){<br>        Rect insets = windowInsets.getSystemWindowInsets();<br>    //insets.bottom = 30<br>    }<br>}</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>ControlRobotsActivity.java<span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure>
<p>@Override<br>public void onCreate(Bundle savedInstanceState){</p>
<p>   WatchViewStub stub = new WatchViewStub(this);<br>    stub.setRectLayout(R.layout.activity_control_robots_rect);<br>    stub.setRoundLayout(R.layout.activity_control_robots_round);</p>
<pre><code>stub.setOnLayoutInflatedListener(<span class="keyword">new</span> WatchViewStub.OnLayoutInflatedListener(){
    <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onLayoutInflated</span><span class="params">(WatchViewStub stub)</span></span>{
        stub.findViewById(R.id.start_invasion).setOnClickListener(mClick);
    }
});
setContentView(stub);
</code></pre><p>}</p>
<p>```</p>
<p>该库同时也提供叫做<code>盒状插入布局的新布局管理器</code>，它拓展了框架布局，让开发师能够同时在方形与圆形屏幕上使用同一布局。</p>
<h1 id="Android_Wear表盘（WatchFace）设计与开发">Android Wear表盘（WatchFace）设计与开发</h1><p>不得不承认，Google在表盘方面上还是很鼓励第三方开发者去自由创作的，有别于<br><a href="http://www.leikeji.com/article?2264" target="_blank" rel="external">Apple Watch不允许接入第三方watch face应用</a>的做法。</p>
<p><a href="http://code.tutsplus.com/tutorials/creating-an-android-wear-watch-face--cms-23718" target="_blank" rel="external">AndroidWear CanvasWatchFaceService</a></p>
<h1 id="Android_Wear更多系列教程：">Android Wear更多系列教程：</h1><blockquote>
<p>博主认为，目前天朝的可穿戴社区仍处于起步阶段，很多资源还不丰富，但是天朝程序猿的力量是强大的，相信随着更多wear developers的加入，可穿戴的社区会愈来愈壮大，最后仅以自己微薄之力，为Android Wear开源做出一点贡献，希望能帮助到更多的人。</p>
</blockquote>
<p>下面汇总了目前国内比较好的一些Android Wear资源，请参考：</p>
<ul>
<li><p>开发类</p>
<ul>
<li><a href="http://developer.android.com/wear/index.html" target="_blank" rel="external">Android Wear Google官方教程（请翻墙，或者自己搜镜像）</a></li>
<li><a href="http://dev.seacat.cn/index.html" target="_blank" rel="external">Android Wear Google官方教程 <code>穿戴猫</code>汉化版本</a></li>
<li><a href="http://bbs.seacat.cn/forum-106-1.html" target="_blank" rel="external">Android Wear <code>穿戴猫</code>社区原创基础教程</a></li>
<li><a href="http://www.tuicool.com/articles/F7Z3Yj" target="_blank" rel="external">Android Wear - App Structure for Android Wear（应用结构)</a></li>
<li><a href="http://www.cnblogs.com/benhero/p/4273800.html" target="_blank" rel="external">benhero博客_Android Wear开发学习指南</a></li>
<li><a href="http://code.tutsplus.com/tutorials/introduction-to-android-wear-hands-on--cms-22157" target="_blank" rel="external">Android Wear_Hands-On</a></li>
<li><a href="http://code.tutsplus.com/tutorials/creating-an-android-wear-watch-face--cms-23718" target="_blank" rel="external">AndroidWear CanvasWatchFaceService</a></li>
<li><a href="http://code.tutsplus.com/articles/introduction-to-android-wear-the-basics--cms-22042" target="_blank" rel="external">Introduction to Android Wear: The Basics</a></li>
<li><a href="http://code.tutsplus.com/tutorials/enhanced-and-wearable-ready-notifications-on-android--cms-21868" target="_blank" rel="external">Enhanced and Wearable-Ready Notifications on Android</a></li>
<li><a href="http://ask.android-studio.org/?/explore/category-wear" target="_blank" rel="external">Ask AndroidStudio Wear问答社区</a></li>
</ul>
</li>
<li><p>设计类 </p>
<ul>
<li><a href="http://developer.android.com/design/wear/index.html" target="_blank" rel="external">Google 官方Android Wear设计教程（需要翻墙）</a> </li>
<li><a href="http://developer.android.com/design/wear/watchfaces.html" target="_blank" rel="external">Google 官方Android Wear表盘（WatchFace）设计教程（需要翻墙）</a></li>
<li><a href="http://note.youdao.com/share/?id=1a46e80cb5ea07b5c755d38b65ff9576&amp;type=note" target="_blank" rel="external">Google Android Wear 设计规范学习心得 </a></li>
<li><a href="http://tencentos.ui.cn/" target="_blank" rel="external">TencentOS智能手表表盘设计大赛</a></li>
<li><a href="http://facerepo.com/app/" target="_blank" rel="external">FaceRepo for WatchMaker/Facer表盘引擎收集网站</a></li>
</ul>
</li>
</ul>
<h1 id="Google_Play_上热门的Android_Wear应用">Google Play 上热门的Android Wear应用</h1><blockquote>
<p>博主收集了一些谷歌市场上比较热门的Android Wear应用，期待更多朋友的补充和意见，大家可以下载下来体验，翻不了墙的同学请默哀。</p>
</blockquote>
<ul>
<li><p><a href="http://note.youdao.com/share/?id=ee853cdb7e4283bade26e485d6ca2c60&amp;type=note" target="_blank" rel="external">22款很棒的Android Wear表盘应用</a></p>
</li>
<li><p><a href="http://note.youdao.com/share/?id=0037856aa8e5e0c2476b9a9f4950baa5&amp;type=note" target="_blank" rel="external">31款很棒的Android Wear应用</a></p>
</li>
<li><p><a href="http://www.magicwatchface.com/zh_cn" target="_blank" rel="external">Magic WatchFace神奇表盘应用</a></p>
</li>
</ul>
<h1 id="热门的可穿戴技术社区">热门的可穿戴技术社区</h1><blockquote>
<p>收录了一些博主目前暂时所知的”可穿戴技术社区”，期待更多朋友的补充和意见！</p>
</blockquote>
<ul>
<li>国内：<ul>
<li><a href="http://www.seacat.cn/" target="_blank" rel="external">穿戴猫</a></li>
<li><a href="http://duwear.baidu.com/" target="_blank" rel="external">DuWear</a></li>
<li><a href="http://ticwear.com/" target="_blank" rel="external">Ticwear</a></li>
<li><a href="http://watch.tos.cn/" target="_blank" rel="external">Tencent OS for Watch</a></li>
<li><a href="http://www.watchkong.com/forum/forum.php" target="_blank" rel="external">手表控</a></li>
<li><a href="http://www.leikeji.com/" target="_blank" rel="external">雷科技</a></li>
<li><a href="http://wearable.hqbpc.com/" target="_blank" rel="external">可穿戴设备</a></li>
<li><a href="http://www.kongnar.com/" target="_blank" rel="external">控哪儿网</a></li>
<li><a href="http://www.mapelf.com/" target="_blank" rel="external">出行精灵</a></li>
</ul>
</li>
<li>国外：<ul>
<li>由于天朝特殊原因，等以后更新。 </li>
</ul>
</li>
</ul>
<h1 id="Android_Wear相关产品宣传视频">Android Wear相关产品宣传视频</h1><ul>
<li><a href="http://www.cgangs.com/article/3467?source=sinaweibo" target="_blank" rel="external">Google：wear what you want</a></li>
<li><a href="http://www.tudou.com/programs/view/jKv0PSWHdCY/" target="_blank" rel="external">Moto360创意广告</a></li>
<li><a href="http://baidu.fun.tv/watch/2542550633994583670.html" target="_blank" rel="external">Moto360中文应用场景广告</a></li>
<li><a href="http://my.tv.sohu.com/us/243481507/79477160.shtml" target="_blank" rel="external">华为AndroidWear智能手表官方宣传片1</a></li>
<li><a href="http://my.tv.sohu.com/us/5747262/78630855.shtml" target="_blank" rel="external">华为AndroidWear智能手表官方宣传片2</a></li>
</ul>
<h1 id="加入我们">加入我们</h1><p>组织在这里(请猛戳链接)：<a href="https://github.com/AndroidWearDemo" target="_blank" rel="external">AndroidWear-CN</a></p>
<p><img src="http://7xi6qz.com1.z0.glb.clouddn.com/github_myblogAndroidWear-CN.png" alt=""></p>
<blockquote>
<p><strong>转载</strong>请注明<strong>出处+原文链接+原文作者</strong>，侵权必究，谢谢！<br>持续更新中</p>
</blockquote>
</android.support.wearable.view.dismissoverlayview>  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/原创博文/">原创博文</a>►<a class="article-category-link" href="/categories/原创博文/Android开发笔记/">Android开发笔记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android/">Android</a><a href="/tags/AndroidWear/">AndroidWear</a><a href="/tags/智能可穿戴/">智能可穿戴</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://daijiale.github.io/2015/05/04/最全的AndroidWear开发笔记/" data-title="下次人家问再你怎么入门AndroidWear，你就甩这篇文章给TA | DaiJiale&#39;s Blog" data-tsina="3173290371" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/05/06/ADB常用Shell命令/" title="常用Adb Shell命令">
  <strong>上一篇：</strong><br/>
  <span>
  常用Adb Shell命令</span>
</a>
</div>


<div class="next">
<a href="/2015/04/27/我的一点看法关于目前市面上流行的Git托管服务社区/"  title="我的一点看法关于市面上流行的Git托管服务社区">
 <strong>下一篇：</strong><br/> 
 <span>我的一点看法关于市面上流行的Git托管服务社区
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/05/04/最全的AndroidWear开发笔记/" data-title="下次人家问再你怎么入门AndroidWear，你就甩这篇文章给TA" data-url="http://daijiale.github.io/2015/05/04/最全的AndroidWear开发笔记/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#本文作者"><span class="toc-number">1.</span> <span class="toc-text">本文作者</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Jiale_Dai"><span class="toc-number">1.1.</span> <span class="toc-text">Jiale Dai</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#写在开头"><span class="toc-number">2.</span> <span class="toc-text">写在开头</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#核心元素："><span class="toc-number">2.1.</span> <span class="toc-text">核心元素：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建一个Wear_Apps的基础（wear_app能做到什么？）："><span class="toc-number">2.2.</span> <span class="toc-text">构建一个Wear Apps的基础（wear app能做到什么？）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gmail"><span class="toc-number">2.2.1.</span> <span class="toc-text">Gmail</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hangouts"><span class="toc-number">2.2.2.</span> <span class="toc-text">Hangouts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Google_Camera"><span class="toc-number">2.2.3.</span> <span class="toc-text">Google Camera</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Google_Maps"><span class="toc-number">2.2.4.</span> <span class="toc-text">Google Maps</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#搭建云驱动的Android_Wear_Apps"><span class="toc-number">3.</span> <span class="toc-text">搭建云驱动的Android Wear Apps</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#写给设计师们：如何把握Android_Wear下App的设计原则？"><span class="toc-number">4.</span> <span class="toc-text">写给设计师们：如何把握Android Wear下App的设计原则？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#设计思路："><span class="toc-number">4.1.</span> <span class="toc-text">设计思路：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear搭建更高级别的UI"><span class="toc-number">5.</span> <span class="toc-text">Android Wear搭建更高级别的UI</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear_数据层API_DevBytes"><span class="toc-number">6.</span> <span class="toc-text">Android Wear 数据层API DevBytes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear的提醒（Notification）新特性"><span class="toc-number">7.</span> <span class="toc-text">Android Wear的提醒（Notification）新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多页面提醒设计（Multi-page_notifications）"><span class="toc-number">7.1.</span> <span class="toc-text">多页面提醒设计（Multi-page notifications）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提醒堆栈（Notification_Stacks）"><span class="toc-number">7.2.</span> <span class="toc-text">提醒堆栈（Notification Stacks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远程输入（Remote_Input）"><span class="toc-number">7.3.</span> <span class="toc-text">远程输入（Remote Input）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Custom_Display_Cards"><span class="toc-number">7.4.</span> <span class="toc-text">Custom Display Cards</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Notification_Bridging"><span class="toc-number">7.5.</span> <span class="toc-text">Notification Bridging</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear下的全屏App设计理念"><span class="toc-number">8.</span> <span class="toc-text">Android Wear下的全屏App设计理念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#让用户如何退出APP"><span class="toc-number">8.1.</span> <span class="toc-text">让用户如何退出APP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#滑动退出："><span class="toc-number">8.1.1.</span> <span class="toc-text">滑动退出：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear表盘（WatchFace）设计与开发"><span class="toc-number">9.</span> <span class="toc-text">Android Wear表盘（WatchFace）设计与开发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear更多系列教程："><span class="toc-number">10.</span> <span class="toc-text">Android Wear更多系列教程：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Google_Play_上热门的Android_Wear应用"><span class="toc-number">11.</span> <span class="toc-text">Google Play 上热门的Android Wear应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#热门的可穿戴技术社区"><span class="toc-number">12.</span> <span class="toc-text">热门的可穿戴技术社区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Wear相关产品宣传视频"><span class="toc-number">13.</span> <span class="toc-text">Android Wear相关产品宣传视频</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#加入我们"><span class="toc-number">14.</span> <span class="toc-text">加入我们</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/原创博文/Android开发笔记/" title="Android开发笔记">Android开发笔记<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/原创博文/Web开发日记/" title="Web开发日记">Web开发日记<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/原创博文/单反自学笔记/" title="单反自学笔记">单反自学笔记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/原创博文/" title="原创博文">原创博文<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/转载博文/" title="转载博文">转载博文<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/个人故事/" title="个人故事">个人故事<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Hackathon/" title="Hackathon">Hackathon<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Javascript/" title="Javascript">Javascript<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/智能可穿戴/" title="智能可穿戴">智能可穿戴<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/工具神器/" title="工具神器">工具神器<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/代码托管/" title="代码托管">代码托管<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Amaze-UI/" title="Amaze UI">Amaze UI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Json/" title="Json">Json<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/html5/" title="html5">html5<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/拍照摄影/" title="拍照摄影">拍照摄影<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/AndroidWear/" title="AndroidWear">AndroidWear<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Node-js/" title="Node.js">Node.js<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Blog/" title="Blog">Blog<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Ajax/" title="Ajax">Ajax<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/php/" title="php">php<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.daijiale.cn" target="_blank" title="DaiJiale的个人简历页">DaiJiale的个人站点</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.linzhihao.cn" target="_blank" title="我师父的Blog">MasterLin的Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://charles-xiao.github.io/" target="_blank" title="好友肖勇Blog">CharlesXiao的Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://lizhuolun.com/" target="_blank" title="好友卓伦Blog">lizhuolun的Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://stormzhang.com/" target="_blank" title="偶像的Blog（Android_CN OG级人物）">StormZhang的Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me/" target="_blank" title="jacman原创博主">Jark&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.developerclub.cn" target="_blank" title="博主自己独立开发的：一个面向电子科技大学开发者的网上社区">电子科技大学开发者俱乐部</a>
            
          </li>
        
          <li>
            
            	<a href="http://uestc.xyz" target="_blank" title="一个面向电子科技大学Linux开发者的社区">电子科技大学Linux开源社区</a>
            
          </li>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://tongji.cnzz.com/main.php?c=site&a=show&siteid=1254856612" target="_blank" title=" 站点数据统计">站长统计</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Jiale Dai in UESTC. <br/>
			Welcome To My World.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3173290371" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/daijiale" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="https://www.zhihu.com/people/dai-jia-le-35" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:daijiale6239@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by Hexo and Theme Rebuilt From Jacman By</a> © 2015 
		
		<a href="http://www.daijiale.cn">Jiale Dai</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"daijiale"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254856612'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1254856612' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
